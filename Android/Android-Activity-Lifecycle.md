# Activity Lifecycle

## 액티비티 수명 주기에 대한 이해

사용자가 앱을 탐색하고, 앱에서 나가고, 앱으로 다시 돌아가면, 앱의 Activity 인스턴스는 수명 주기 안에서 서로 다른 상태를 통해 전환된다. Activity 클래스는 액티비티가 상태 변화(시스템이 액티비티를 생성, 중단 또는 다시 시작, 액티비티가 있는 프로세스를 종료하는 등)를 알아차릴 수 있는 여러 콜백을 제공한다.

수명 주기 콜백을 잘 구현하면 앱에서 다음과 같은 문제가 발생하지 않도록 예방하는 데 도움이 될 수 있다.

- 사용자가 앱을 사용하는 도중에 전화가 걸려오거나 다른 앱으로 전환할 때 비정상 종료되는 문제

- 사용자가 앱을 활발하게 사용하지 않는 경우 귀중한 시스템 리소스가 소비되는 문제

- 사용자가 앱에서 나갔다가 나중에 돌아왔을 때 사용자의 진행 상태가 저장되지 않는 문제

- 화면이 가로 방향과 세로 방향 간에 회전할 경우, 비정상 종료되거나 사용자의 진행 상태가 저장되지 않는 문제

<br/>

## 액티비티 수명 주기 개념

액티비티 수명 주기 단꼐 간에 전환하기 위해 활동 클래스는 6가지 콜백으로 구성된 핵심 집합 `onCreate(), onStart(), onResume(), onPause(), onStop(), onDestroy()` 를 제공한다. 액티비티가 새로운 상태에 들어가면 시스템은 각 콜백을 호출한다.

<br>

<p align="center">

<img src="https://github.com/dudwns9331/2021-Summer-Kotlin/blob/master/Summer-Technical-Note/assets/activity_lifecycle.PNG" width="500px" height="650px"/>

</p>

<br>

사용자가 활동을 벗어나기 시작하면 시스템은 활동을 해체할 메서드를 호출한다. 어떤 경우에는 부분적으로만 해체하기도 한다. 이때 활동은 여전히 메모리 안에 남아 있으며(예: 사용자가 다른 앱으로 전환할 경우) 포그라운드로 다시 돌아올 수 있다. 사용자가 해당 활동으로 돌아오는 경우 사용자가 종료한 지점에서 활동이 다시 시작된다. 몇 가지 예외를 제외하고 앱은 백그라운드에서 실행될 때 활동을 실행할 수 없다.

<br/>

## 생명주기 콜백

### onCreate()

이 콜백은 시스템이 먼저 활동을 생성할 때 실행되는 것으로, 필수적으로 구현해야 한다. 활동이 생성되면 생성됨 상태가 된다. `onCreate()` 메서드에서 활동의 전체 수명 주기 동안 한 번만 발생해야 하는 기본 애플리케이션 시작 로직을 실행한다. 예를 들어 `onCreate()` 를 구현하면 데이터를 목록에 바인딩하고, 활동을 `ViewModel` 과 연결하고, 일부 클래스 범위 변수를 인스턴스화할 수도 있다. 이 메서드는 `savedInstanceState` 매개변수를 수신하는데, 이는 활동의 이전 저장 상태가 포함된 `Bundle` 객체이다. 이번에 처음 생성된 활동인 경우 `Bundle` 객체의 값은 `null` 이다.

액티비티는 생성됨 상태에 머무르지 않는다. `onCreate()` 메서드가 실행을 완료하면 시작됨 상태가 되고, 시스템이 연달아 `onStart()`와 `onResume()` 메서드를 호출한다.

<br/>

### onStart()

액티비티가 시작됨 상태에 들어가면 시스템은 이 콜백을 호출한다. `onStart()` 가 호출되면 액티비티가 사용자에게 표시되고, 앱은 활동을 포그라운드에 보내 상호작용할 수 있도록 준비한다. 예를 들어 이 메서드에서 앱이 UI를 관리하는 코드를 초기화한다.

`onStart()` 메서드는 매우 빠르게 완료되고, 생성됨 상태와 마찬가지로 활동은 시작됨 상태에 머무르지 않는다. 이 콜백이 완료되면 액티비티가 재개됨 상태에 들어가고, 시스템이 `onResume()` 메서드를 호출한다.

<br/>

### onResume()

활동이 재개됨 상태에 들어가면 포그라운드에 표시되고 시스템이 `onResume()` 콜백을 호출한다. 이 상태에 들어갔을 때 앱이 사용자와 상호작용한다. 어떤 이벤트가 발생하여 앱에서 포커스가 떠날 때까지 앱이 이 상태에 머무른다. 예를 들어 전화가 오거나, 사용자가 다른 활동으로 이동하거나, 기기 화면이 꺼지는 이벤트가 이에 해당한다.

활동이 재개됨 상태로 전환되면 이 활동의 수명 주기와 연결된 모든 수명 주기 인식 구성요소는 `ON_RESUME` 이벤트를 수신한다. 이 상태에서 수명 주기 구성요소가 포그라운드에서 사용자에게 보이는 동안 실행해야 하는 모든 기능을 활성화할 수 있다(예: 카메라 미리보기 시작).

방해되는 이벤트가 발생하면 액티비티는 일시중지됨 상태에 들어가고, 시스템이 `onPause()` 콜백을 호출한다.

활동이 일시중지됨 상태에서 재개됨 상태로 돌아오면 시스템이 `onResume()` 메서드를 다시 한번 호출한다. 따라서 `onResume()` 을 구현하여 `onPause()` 중에 해제하는 구성요소를 초기화하고, 활동이 재개됨 상태로 전환될 때마다 필요한 다른 초기화 작업도 수행해야 한다.

<br/>

### onPause()

시스템은 사용자가 활동을 떠나는 것을 나타내는 첫 번째 신호로 이 메서드를 호출한다(하지만 해당 액티비티가 항상 소멸되는 것은 아님). 액티비티가 포그라운드에 있지 않게 되었다는 것을 나타낸다(다만 사용자가 멀티 윈도우 모드에 있을 경우에는 여전히 표시 될 수도 있음). `onPause()` 메서드를 사용하여 `Activity` 가 일시중지됨 상태일 때 계속 실행(또는 적절히 계속 실행)되어서는 안 되지만 잠시 후 다시 시작할 작업을 일시중지하거나 조정한다.

Android 7.0(API 수준 24) 이상에서는 여러 앱이 멀티 윈도우 모드에서 실행된다. 언제든지 그중 하나의 앱(창)만 포커스를 가질 수 있기 때문에 시스템이 그 외에 모든 다른 앱을 일시중지시킨다.

새로운 반투명 활동(예: 대화상자)이 열린다. 액티비티가 여전히 부분적으로 보이지만 포커스 상태가 아닌 경우에는 일시중지됨 상태로 유지된다.

액티비티가 일시중지됨 상태로 전환하면 이 활동의 수명 주기와 연결된 모든 수명 주기 인식 구성요소는 ON_PAUSE 이벤트를 수신한다. 여기에서 수명 주기 구성요소는 구성요소가 포그라운드에 있지 않을 때 실행할 필요가 없는 기능을 모두 정지할 수 있다(예: 카메라 미리보기 정지).

또한 `onPause()` 메서드를 사용하여 시스템 리소스, 센서 핸들(예: GPS) 또는 액티비티가 일시중지 중이고 사용자가 필요로 하지 않을 때 배터리 수명에 영향을 미칠 수 있는 모든 리소스를 해제할 수도 있다. 그러나 앞서 `onResume()` 섹션에서 언급했듯이 일시중지된 액티비티는 멀티 윈도우 모드에서 여전히 완전히 보이는 상태일 수 있다. 그러므로 멀티 윈도우 모드를 더욱 잘 지원하기 위해 UI 관련 리소스와 작업을 완전히 해제하거나 조정할 때는 `onPause()` 대신 `onStop()` 을 사용하는 것이 좋다.

`onPause()` 는 아주 잠깐 실행되므로 저장 작업을 실행하기에는 시간이 부족할 수 있다. 그러므로 `onPause()` 를 사용하여 애플리케이션 또는 사용자 데이터를 저장하거나, 네트워크 호출을 하거나, 데이터베이스 트랜잭션을 실행해서는 안 된다. 이러한 작업은 메서드 실행이 끝나기 전에 완료되지 못할 수도 있다. 그 대신, 부하가 큰 종료 작업은 `onStop()` 상태일 때 실행해야 한다.

`onPause()` 메서드의 실행이 완료되더라도 활동이 일시중지됨 상태로 남아 있을 수 있다. 오히려 활동은 다시 시작되거나 사용자에게 완전히 보이지 않게 될 때까지 이 상태에 머무른다. 활동이 다시 시작되면 시스템은 다시 한번 `onResume()` 콜백을 호출한다. 활동이 일시중지됨 상태에서 재개됨 상태로 돌아오면 시스템은 `Activity` 인스턴스를 메모리에 남겨두고, 시스템이 `onResume()` 을 호출할 때 인스턴스를 다시 호출한다. 이 시나리오에서는 최상위 상태가 재개됨 상태인 콜백 메서드 중에 생성된 구성요소는 다시 초기화할 필요가 없다. 활동이 완전히 보이지 않게 되면 시스템은 `onStop()` 을 호출한다.

### onStop()

액티비티가 사용자에게 더 이상 표시되지 않으면 중단됨 상태에 들어가고, 시스템은 `onStop()` 콜백을 호출한다. 이는 예를 들어 새로 시작된 액티비티가 화면 전체를 차지할 경우에 적용된다. 시스템은 활동의 실행이 완료되어 종료될 시점에 `onStop()` 을 호출할 수도 있다.

액티비티가 중단됨 상태로 전환하면 이 활동의 수명 주기와 연결된 모든 수명 주기 인식 구성요소는 `ON_STOP` 이벤트를 수신한다. 여기에서 수명 주기 구성요소는 구성요소가 화면에 보이지 않을 때 실행할 필요가 없는 기능을 모두 정지할 수 있다.

`onStop()` 메서드에서는 앱이 사용자에게 보이지 않는 동안 앱은 필요하지 않은 리소스를 해제하거나 조정해야 한다. 예를 들어 앱은 애니메이션을 일시중지하거나, 세밀한 위치 업데이트에서 대략적인 위치 업데이트로 전환할 수 있다. `onPause()` 대신 `onStop()`을 사용하면 사용자가 멀티 윈도우 모드에서 활동을 보고 있더라도 UI 관련 작업이 계속 진행된다.

또한 `onStop()`을 사용하여 CPU를 비교적 많이 소모하는 종료 작업을 실행해야 한다. 예를 들어 정보를 데이터베이스에 저장할 적절한 시기를 찾지 못했다면 `onStop()` 상태일 때 저장할 수 있다.

활동이 중단됨 상태에 들어가면 `Activity` 객체는 메모리 안에 머무르게 된다. 이 객체가 모든 상태 및 멤버 정보를 관리하지만 창 관리자와 연결되어 있지는 않는다. 활동이 다시 시작되면 이 정보를 다시 호출한다. 최상위 상태가 재개됨 상태인 콜백 메서드 중에 생성된 구성요소는 다시 초기화할 필요가 없다. 또한 시스템은 레이아웃에 있는 각 `View` 객체의 현재 상태도 기록한다.

활동은 정지됨 상태에서 다시 시작되어 사용자와 상호작용하거나, 실행을 종료하고 사라진다. 활동이 다시 시작되면 시스템은 `onRestart()` 를 호출한다. `Activity` 가 실행을 종료하면 시스템은 `onDestroy()` 를 호출한다.

### onDestroy()

`onDestroy()` 는 활동이 소멸되기 전에 호출한다. 시스템은 다음 중 하나에 해당할 때 이 콜백을 호출한다.

1. (사용자가 활동을 완전히 닫거나 활동에서 `finish()`가 호출되어) 활동이 종료되는 경우
2. 구성 변경(예: 기기 회전 또는 멀티 윈도우 모드)으로 인해 시스템이 일시적으로 활동을 소멸시키는 경우

활동이 소멸됨 상태로 전환하면 이 활동의 수명 주기와 연결된 모든 수명 주기 인식 구성요소는 `ON_DESTROY` 이벤트를 수신한다. 여기서 수명 주기 구성요소는 활동이 소멸되기 전에 필요한 것을 정리할 수 있다.

활동에 소멸되는 이유를 결정하는 로직을 입력하는 대신 `ViewModel` 객체를 사용하여 활동의 관련 뷰 데이터를 포함해야 한다. 활동이 구성 변경으로 인해 다시 생성될 경우 `ViewModel`은 그대로 보존되어 다음 활동 인스턴스에 전달되므로 추가 작업이 필요하지 않다. 활동이 다시 생성되지 않을 경우 `ViewModel`은 `onCleared()` 메서드를 호출하여 활동이 소멸되기 전에 모든 데이터를 정리해야 한다.

이와 같은 두 가지 시나리오는 `isFinishing()` 메서드로 구분할 수 있다.

활동이 종료되는 경우 `onDestroy()`는 활동이 수신하는 마지막 수명 주기 콜백이 된다. 구성 변경으로 인해 `onDestroy()`가 호출되는 경우 시스템이 즉시 새 활동 인스턴스를 생성한 다음, 새로운 구성에서 그 새로운 인스턴스에 관해 `onCreate()` 를 호출한다.

`onDestroy()` 콜백은 이전의 콜백에서 아직 해제되지 않은 모든 리소스(예: `onStop()`)를 해제해야 한다.
